{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","children":[{"parent":"5e199c288f2e","children":[{"parent":"1ce61c8e5c36","children":[{"parent":"d20c2c68ee92","children":[{"parent":"f063eaa3efb8","children":[],"id":"edd4132a1639","title":"set<br>get<br>append<br>setrange<br>getrange<br>strlen"}],"id":"f063eaa3efb8","title":"基本常用指令"}],"id":"d20c2c68ee92","title":"字符串"},{"parent":"1ce61c8e5c36","children":[{"parent":"7b41ea4032da","children":[{"parent":"7fe3c507af7a","children":[{"parent":"b6081d71aa83","children":[],"id":"554af624f0b5","title":"抢购，秒杀，详情页，点赞，评论<br>规避并发下对数据库的事务操作<br>完全由redis 内存操作代替"}],"id":"b6081d71aa83","title":"incr"}],"id":"7fe3c507af7a","title":"基本常用指令"}],"id":"7b41ea4032da","title":"数值"},{"parent":"1ce61c8e5c36","children":[{"parent":"a15e31da5ecc","children":[],"id":"858cc7946629","title":"setbit&nbsp;<br>bitcount<br>bitpos<br>bitop"},{"parent":"a15e31da5ecc","children":[{"parent":"44974a36e231","children":[{"parent":"0aa472df7f21","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"af6af72262ed","title":"矩阵思想<br>day&nbsp; &nbsp; 01 02 03 04 05 06<br>user1&nbsp; 0&nbsp; &nbsp;1&nbsp; 0&nbsp; &nbsp; 1&nbsp; &nbsp;0&nbsp; &nbsp;1<br>每个用户 46B"}],"id":"0aa472df7f21","title":"在某一个随机窗口统计某个用户的登陆天数/登陆状态<br>-&gt;<br>一个用户对应365个字节,哪一天登陆了 就在哪个位置上setbit user n 1 否则默认为0"},{"parent":"44974a36e231","children":[{"parent":"4019eebb1151","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"45db1abad4d5","title":"矩阵思想<br>user&nbsp; &nbsp;u1 u2 u3 u4 u5 u6<br>day&nbsp; &nbsp; 0&nbsp; &nbsp;1&nbsp; &nbsp; 0&nbsp; &nbsp; 1&nbsp; 1&nbsp; &nbsp;1<br>"}],"id":"4019eebb1151","title":"统计某一些日子的活跃用户数量 随机窗口<br>-&gt;<br>用户id(数字) 代表了他在二进制表示中是第几位二进制<br>setbit 20200601 1 1 代表了6.1号这天id为1的用户登录了<br>setbit 20200602 2 1 代表了6.2号这天id为2的用户登陆了<br>统计: bitop or destkey 20200601 20200602<br>&nbsp;bitcount destkey 0 -1"}],"id":"44974a36e231","title":"使用场景"}],"id":"a15e31da5ecc","title":"bitmap"}],"id":"1ce61c8e5c36","title":"String<br>byte"},{"parent":"5e199c288f2e","children":[{"parent":"8dec8f9f7505","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"d11f037a26d0","title":"Redis 中list 实现是一个双向链表，<br>且Key 中除了Key 还含有头尾两个节点head &amp; tail<br>节点内容可以重复"},{"parent":"8dec8f9f7505","children":[{"parent":"afa46f0e3db8","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"9931a5b6faa0","title":"栈<br>同向命令"},{"parent":"afa46f0e3db8","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"55893e70c560","title":"阻塞队列<br>反向命令"},{"parent":"afa46f0e3db8","children":[],"id":"9b06b172c5a5","title":"数组"},{"parent":"afa46f0e3db8","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"9fc84ef6f9ba","title":"阻塞队列、单播队列<br>FIFO&nbsp;"}],"id":"afa46f0e3db8","title":"使用场景"},{"parent":"8dec8f9f7505","children":[{"parent":"636d5c9cfc03","children":[],"id":"f8ed6359b73c","title":"lpush"},{"parent":"636d5c9cfc03","children":[],"id":"b2a4221ede0b","title":"rpush"},{"parent":"636d5c9cfc03","children":[],"id":"5d612184200a","title":"rpop"},{"parent":"636d5c9cfc03","children":[],"id":"f9a89132754c","title":"lpop"},{"parent":"636d5c9cfc03","children":[],"id":"f0253ebc6963","title":"blpop<br>"}],"id":"636d5c9cfc03","title":"主要命令"}],"id":"8dec8f9f7505","title":"List"},{"parent":"5e199c288f2e","children":[{"parent":"5b8d2521d869","children":[],"id":"bc350788044c","title":"map(k - v )"},{"parent":"5b8d2521d869","children":[],"id":"d87eca1f66a1","title":"对field 进行数值计算<br>场景，点赞，收藏，详情页"}],"id":"5b8d2521d869","title":"Hash"},{"parent":"5e199c288f2e","children":[{"parent":"10c0406c3439","children":[],"id":"267b4d048acc","title":"无序<br>去重<br>"},{"parent":"10c0406c3439","children":[{"parent":"4d2203c9860a","children":[],"id":"cac57d935a9d","title":"sinter<br>求多个集合的交集"},{"parent":"4d2203c9860a","children":[],"id":"17825e22a17b","title":"sinterstore destkey keys<br>求多个集合的交集并保存到destkey 中"},{"parent":"4d2203c9860a","children":[],"id":"c5b9c9c82a70","title":"sunion<br>并集"},{"parent":"4d2203c9860a","children":[],"id":"22d6d9b5248e","title":"sdiff k1 k2<br>k1左差集"},{"parent":"4d2203c9860a","children":[{"parent":"b603f8df344c","children":[{"parent":"6701329314e0","children":[],"id":"dad5304ac904","title":"抽奖<br>举例<br>抽奖10个奖品<br>用户： &lt; 10 / &gt;10<br>中奖是否重复<br>解决家庭斗争"}],"id":"6701329314e0","title":"使用场景"}],"id":"b603f8df344c","title":"srandmember key count&nbsp;<br>正数 取出一个去重的结果集(不超过key的已有集)<br>负数:取出一个带重复的结果集(满足数量)<br>0 不返回"}],"id":"4d2203c9860a","title":"主要命令"}],"id":"10c0406c3439","title":"Set"},{"parent":"5e199c288f2e","children":[{"parent":"2ab01750aef2","children":[],"id":"710e41203d52","title":"物理内存左小右大<br>不随命令发生变化<br>zrange<br>zrevrange"},{"parent":"2ab01750aef2","children":[],"id":"9980e8684679","title":"集合操作<br>并集，交集"},{"parent":"2ab01750aef2","children":[{"parent":"2f4bfa991706","children":[{"parent":"4e9e99af1731","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"cccd5d113046","title":"跳跃表<br>https://www.cnblogs.com/acfox/p/3688607.html<br>"}],"id":"4e9e99af1731","title":"skip list<br>跳跃表"}],"id":"2f4bfa991706","title":"排序是怎么实现的<br>增删查改的速度？"}],"id":"2ab01750aef2","title":"ZSET/Sorted Set"}],"id":"5e199c288f2e","title":"数据类型"}],"children":[{"parent":"root","children":[{"parent":"1eec8c9a72f5","children":[],"id":"a18debf9a226","title":"NIO多路复用"},{"parent":"1eec8c9a72f5","children":[],"id":"7261f585cb15","title":"epoll"}],"id":"1eec8c9a72f5","title":"I/O模型"},{"parent":"root","children":[{"parent":"4df7545e8ded","children":[{"parent":"8f69f9c568e4","children":[],"id":"cdfc9717830d","title":"public<br>subscirbe"}],"id":"8f69f9c568e4","title":"消息订阅"},{"parent":"4df7545e8ded","children":[],"id":"276f8e30d02f","title":"pipeline"},{"parent":"4df7545e8ded","children":[{"parent":"d99ef9cc38d6","children":[],"id":"8ae8770d6fc8","title":"主要命令"}],"id":"d99ef9cc38d6","title":"事务"},{"parent":"4df7545e8ded","children":[],"id":"a246c21ff91e","title":"modules"},{"parent":"4df7545e8ded","children":[{"parent":"592711791eb3","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"bab0f9d9257d","title":"https://www.cnblogs.com/CodeBear/p/10911177.html<br>"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"592711791eb3","title":"布隆过滤器"},{"parent":"4df7545e8ded","children":[],"id":"e7c8b6f27cac","title":"缓存LRU"},{"parent":"4df7545e8ded","children":[{"parent":"fa3fcbe23dc4","children":[{"parent":"dd41b3d246a8","children":[{"parent":"822f17f745f4","children":[],"id":"3f3f03483099","title":"如何设定redis的内存<br>maxmermory &lt;bytes&gt;"}],"id":"822f17f745f4","title":"缓存数据并不太重要，因为不是全量数据，<br>缓存应该随着访问变化<br>热数据"},{"parent":"dd41b3d246a8","children":[{"parent":"85efac5b8f42","children":[],"id":"5c557611d0fe","title":"1.不会随着访问延长有效期"},{"parent":"85efac5b8f42","children":[],"id":"f0bc93604a65","title":"2.发生写事件会剔除过期事件"},{"parent":"85efac5b8f42","children":[],"id":"f07c21783398","title":"3.有效期会倒计时 切redis 不能延长"},{"parent":"85efac5b8f42","children":[],"id":"d4ac9f550b28","title":"4.定时"},{"parent":"85efac5b8f42","children":[{"parent":"651bff7f0e93","children":[],"id":"26b78491eef6","title":"1.被动访问时判断<br>2周期轮询判定(增量)<br>目的：稍微牺牲下内存，保住性能<br>"}],"id":"651bff7f0e93","title":"如何淘汰过期的keys<br>过期的判定原理"}],"id":"85efac5b8f42","title":"业务逻辑决定了key的有效期<br>"},{"parent":"dd41b3d246a8","children":[{"parent":"ff153d6257a2","children":[{"parent":"84fabbe4a0bc","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"a2e85fc48d33","title":"多久没有碰，最少使用"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"84fabbe4a0bc","title":"LRU"},{"parent":"ff153d6257a2","children":[{"parent":"8666e07ba378","children":[],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"d51615a071cb","title":"碰了多少次"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"8666e07ba378","title":"LFU"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"ff153d6257a2","title":"因为内存是有限的，随着访问的变化，应该淘汰冷数据-&gt;业务运转"},{"parent":"dd41b3d246a8","children":[{"parent":"4b5a4069f2ac","children":[],"id":"5f743415f056","title":"击穿"},{"parent":"4b5a4069f2ac","children":[],"id":"4bedaff955e6","title":"雪崩"},{"parent":"4b5a4069f2ac","children":[],"id":"c3f56287f3b7","title":"穿透"},{"parent":"4b5a4069f2ac","children":[],"id":"b19a77f91cbb","title":"一致性(双写)"}],"id":"4b5a4069f2ac","title":"缓存的常见问题:"}],"id":"dd41b3d246a8","title":"缓存"},{"parent":"fa3fcbe23dc4","children":[{"parent":"09a52cc6e146","children":[{"parent":"851a59ca5dd9","children":[],"style":{"color":"#ffffff"},"id":"62b0a65ad3e3","title":"时点性"},{"parent":"851a59ca5dd9","children":[],"style":{"color":"#ffffff"},"id":"5ae086677515","title":"RDB持久化是指在指定的时间间隔内将内存中的数据和操作通过快照的方式保存到redis bin目录下的一个默认名为 dump.rdb的文件，可以通过配置设置自动的快照持久化的方式，我们可以配置redis在n秒内进行快照的时间，如果超过这个时间节点，将会自动执行快照操作。"},{"parent":"851a59ca5dd9","children":[],"style":{"color":"#ffffff"},"id":"cf5f08a1e250","title":"虽然这种方式方便快捷，但是无法保证数据的绝对安全可靠，如果服务器在非备份时间跨度内发生了故障，无法做到对当前状态的实时保存，导致数据丢失。而且每次保存 RDB文件时， Redis都需要 fork()出一个子进程，由子进程来执行具体的持久化工作，对资源消耗较大。"},{"parent":"851a59ca5dd9","children":[{"parent":"3390907f24ce","children":[{"parent":"7dc7e2433c7e","children":[{"parent":"10841480229e","children":[],"style":{"color":"#ffffff"},"id":"6f3a37fe8729","title":"fork()<br>1.速度快<br>2.空间少<br>fork.copyonwrite()<br>创建子进程并不发生复制<br>创建进程的速度变快了<br>使用的都是指针"}],"style":{"color":"#ffffff"},"id":"10841480229e","title":"所以如果 父进程是redis 内存数据是10g ，创建子进程的时候应该要考虑什么?<br>1.速度<br>2.内存空间够不够"}],"style":{"color":"#ffffff"},"id":"7dc7e2433c7e","title":"在使用linux的时候，父子进程<br>父进程可以让子进程看到数据!<br>linux 中 export 变量 <br>子进程的对变量的修改不会影响父进程<br>父进程的修改也不会影响子进程<br>"}],"style":{"color":"#ffffff"},"id":"3390907f24ce","title":"管道:<br>1.衔接 前一个命令的输出作为后一个命令的输入<br>2.管道会触发创建【子进程】<br><br>echo $$ | more<br>echo $BASHPID | MORE&nbsp;<br>$$ 高于 |&nbsp;"},{"parent":"851a59ca5dd9","children":[{"parent":"529d7197ce84","children":[{"parent":"27ab89a2e20c","children":[],"style":{"color":"#ffffff"},"id":"2a3fba0cb708","title":"人为 阻塞主进程&nbsp;"},{"parent":"27ab89a2e20c","children":[],"style":{"color":"#ffffff"},"id":"3f7fe11dcf08","title":"使用场景，比较明确，需要关机维护"}],"style":{"color":"#ffffff"},"id":"27ab89a2e20c","title":"save"},{"parent":"529d7197ce84","children":[{"parent":"378d7d55c0f3","children":[],"style":{"color":"#ffffff"},"id":"ae9e00b11233","title":"fork 创建子进程"}],"style":{"color":"#ffffff"},"id":"378d7d55c0f3","title":"bgsave"},{"parent":"529d7197ce84","children":[],"style":{"color":"#ffffff"},"id":"f2d1135d5d51","title":"配置文件中给出bgsave 的规则，用的是save这个标识符"},{"parent":"529d7197ce84","children":[],"style":{"color":"#ffffff"},"id":"32983cc51367","title":"dbfilename - &gt; dump.rdb<br><br>"}],"style":{"color":"#ffffff"},"id":"529d7197ce84","title":"指令"},{"parent":"851a59ca5dd9","children":[{"parent":"dd0a290481d0","children":[],"style":{"color":"#ffffff"},"id":"372f7091d1b1","title":"不支持拉链，只有一个dump.rdb file"},{"parent":"dd0a290481d0","children":[],"style":{"color":"#ffffff"},"id":"a885ce5f3b35","title":"丢失的数据相对多一些"}],"style":{"color":"#ffffff"},"id":"dd0a290481d0","title":"弊端"},{"parent":"851a59ca5dd9","children":[],"style":{"color":"#ffffff"},"id":"a04371bd5811","title":"优点:类似java中的序列化，恢复速度相对快"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"rgb(255, 255, 255)","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"851a59ca5dd9","title":"快照、副本<br>RDB"},{"parent":"09a52cc6e146","children":[{"parent":"08112b31239f","children":[{"parent":"3419fd4fe84b","children":[],"style":{"color":"#ffffff"},"id":"aa00581ec3dd","title":"丢失数据相对少，类似audit log"},{"parent":"3419fd4fe84b","children":[{"parent":"664ea409c1e2","children":[],"style":{"color":"#ffffff","font-size":"22px"},"id":"11cbcdddc491","title":"在4.0版本以后 ，AOF包含了RDB全量，增加记录新的写操作"}],"collapsed":false,"style":{"color":"#ffffff"},"id":"664ea409c1e2","title":"redis 中RDB 和AOF 可以同时开启，但恢复的话，只会拿AOF恢复<br>"},{"parent":"3419fd4fe84b","children":[{"parent":"750625797524","children":[],"style":{"color":"#ffffff"},"id":"c93024be51f2","title":"需要设计一个方案让日志/AOF 足够小:<br>hdfs,fsimage + edits.log&nbsp;<br>让日志只记录增量合并的过程<br><br>"},{"parent":"750625797524","children":[{"parent":"ab1b058118f3","children":[{"parent":"b4fc02962341","children":[{"parent":"c79acfc12a7f","children":[],"style":{"color":"#ffffff"},"id":"80227d4ca1cc","title":"最终也是变成一个纯指令的日志文件"}],"style":{"color":"#ffffff"},"id":"c79acfc12a7f","title":"删除抵消的命令<br>合并重复的命令<br><br>"}],"style":{"color":"#ffffff"},"id":"b4fc02962341","title":"重写"}],"style":{"color":"#ffffff"},"id":"ab1b058118f3","title":"4.0以前"},{"parent":"750625797524","children":[{"parent":"2af7e84b2d89","children":[{"parent":"9556ad6d9a37","children":[{"parent":"cf917db77388","children":[],"style":{"color":"#ffffff"},"id":"67f13706eb29","title":"AOF是一个混合体<br>利用了RDB恢复快，利用了日志的全量"}],"style":{"color":"#ffffff"},"id":"cf917db77388","title":"将老的数据RDB到AOF文件中<br>讲增量的部分已指令的方式 Append 到AOF 上"}],"style":{"color":"#ffffff"},"id":"9556ad6d9a37","title":"重写"},{"parent":"2af7e84b2d89","children":[{"parent":"2d025bd1c00f","children":[{"parent":"6b3b63cb68a5","children":[],"style":{"color":"#ffffff"},"id":"d6192be6d466","title":"NO :<br>当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。<br><br>"},{"parent":"6b3b63cb68a5","children":[],"style":{"color":"#ffffff"},"id":"2a6e19c5f101","title":"everysec:(Defuault )<br>当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一 次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。<br><br>在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作。<br><br>这一操作在大多数数据库系统中被称为group commit，就是组合多次写操作的数据，一次性将日志写到磁盘。<br>"},{"parent":"6b3b63cb68a5","children":[],"style":{"color":"#ffffff"},"id":"c39d2564bf1f","title":"ALWAYS:<br>当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响<br>"}],"style":{"color":"#ffffff"},"id":"6b3b63cb68a5","title":"有三种写IO的级别<br>appendonly yes&nbsp;<br>appendfilename 'xxx.aof'<br>NO -&gt;appendfsync no<br>ALWAYS&nbsp;appendfsync always<br>每秒&nbsp;appendfsync everysec"},{"parent":"2d025bd1c00f","children":[{"parent":"e592aabef475","children":[],"id":"91487fd947ae","title":"appendonly yes<br><br>appendfilename \"appendonly.aof\"<br><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br>appendfsync always<br>appendfsync everysec<br>appendfsync no&nbsp;<br>"}],"id":"e592aabef475","title":"config"}],"style":{"color":"#ffffff"},"id":"2d025bd1c00f","title":"redis 是内存数据库，写操作会触发IO"}],"style":{"color":"#ffffff"},"id":"2af7e84b2d89","title":"4.0以后"}],"style":{"color":"#ffffff"},"id":"750625797524","title":"弊端，体量无限变大 -&gt;恢复慢"}],"style":{"color":"#ffffff"},"id":"3419fd4fe84b","title":"redis 的写操作记录到文件中"}],"style":{"background-color":"rgb(255, 83, 92)","border-radius":"6px","color":"#ffffff","border-width":"0px","border-color":"rgb(255, 255, 255)","border-style":"none"},"id":"08112b31239f","title":"日志<br>AOF"}],"id":"09a52cc6e146","title":"持久化"}],"id":"fa3fcbe23dc4","title":"redis作为缓存与数据库的区别"},{"parent":"4df7545e8ded","children":[{"parent":"db8e747dcd6b","children":[{"parent":"8217a0f7c1b3","children":[],"id":"e1ea1edb8a7c","title":"X轴：代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上；<br>如读写分离<br>"},{"parent":"8217a0f7c1b3","children":[],"id":"c28ddcf75981","title":"Y轴:关注应用中职责的划分，比如数据类型，交易执行类型的划分；"},{"parent":"8217a0f7c1b3","children":[],"id":"8d35a07c8b6f","title":"Z轴:关注服务和数据的优先级划分，如分地域划分。"},{"parent":"8217a0f7c1b3","image":{"w":1327,"h":786,"url":"http://cdn2.processon.com/5f1d3ce9e4b0a1b3e18ac290?e=1595755257&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:5b0OW7iDq-AvsOFshYEpy35rwfY="},"children":[],"id":"9dadf28c81a3","title":""}],"id":"8217a0f7c1b3","title":"AKF原则<br>AKF扩展立方体(Scalability Cube)<br>"},{"parent":"db8e747dcd6b","children":[{"parent":"e96b83e6e051","children":[{"parent":"15d6c13aa071","children":[],"id":"c0093c6175bf","title":"https://www.jianshu.com/p/06ab9daf921d<br>"},{"parent":"15d6c13aa071","children":[{"parent":"cb351c8459b1","children":[],"id":"b416e5164f30","title":"通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。<br>"},{"parent":"cb351c8459b1","children":[],"id":"f8657646cfa0","title":"当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。<br>"}],"id":"cb351c8459b1","title":"作用"},{"parent":"15d6c13aa071","image":{"w":767,"h":1007,"url":"http://cdn2.processon.com/5f1d4a66e4b0e3954188edee?e=1595758711&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:UdsmHiWERK8CxIt1GRDhbyXcw_M="},"children":[],"id":"94b622f77d2b","title":""}],"id":"15d6c13aa071","title":"哨兵模式"}],"id":"e96b83e6e051","title":"集群"}],"id":"db8e747dcd6b","title":"集群，多机部署"},{"parent":"4df7545e8ded","children":[{"parent":"24af9c66629f","children":[],"id":"3333cbcebe15","title":"replica-serve-stale-data yes<br>replica-read-only yes<br>repl-diskless-sync no<br><br>repl-backlog-size 1mb<br>#增量复制<br><br>min-replicas-to-write 3<br>min-replicas-max-lag 10"},{"parent":"24af9c66629f","image":{"w":881,"h":476,"url":"http://cdn2.processon.com/5f1d47e3e4b05602832dbcd3?e=1595758067&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:oskM9G1bzsrU_PyOFZ7y-LZegXo="},"children":[],"id":"e3a52b9cbb3f","title":""}],"id":"24af9c66629f","title":"主从复制"}],"id":"4df7545e8ded","title":"redis 进阶使用"}],"root":true,"style":{"background-color":"#f68b1f"},"theme":"caihongpao","id":"root","title":"Redis","structure":"mind_right"}},"meta":{"exportTime":"2020-07-26 18:47:12","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}